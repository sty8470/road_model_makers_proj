import matplotlib.pyplot as plt
import numpy as np


import os
import sys
current_path = os.path.dirname(os.path.realpath(__file__))
sys.path.append(os.path.normpath(os.path.join(current_path, '../../')))

from lib.common.polygon_util import minimum_bounding_rectangle, calculate_centroid

points_list = []
# U
points1 = np.array([[308.5785600178642, 254.82536589819938, 9.704490661621094], [306.8983774884837, 254.72328550182283, 9.708831787109375], [306.2075295414543, 221.9224690948613, 9.665153503417969], [341.2306717141764, 220.14512672973797, 9.280158996582031], [342.4504108900437, 221.5122447279282, 9.273460388183594], [343.9668852351606, 222.6391553170979, 9.262802124023438], [344.36585265316535, 254.0085372570902, 9.306076049804688], [342.798487719032, 253.99880644027144, 9.338539123535156], [342.29701126145665, 221.77754259249195, 9.275321960449219], [308.00554084026953, 223.57345954095945, 9.665870666503906], [308.5785600178642, 254.82536589819938, 9.704490661621094]])
# ㄱ
points2 = np.array([[335.8026372892782, -4.905850363895297, 6.5362396240234375], [334.1850110308733, -3.428548800293356, 6.6805572509765625], [304.2720513235545, -2.9315768321976066, 6.507057189941406], [304.2048608654877, -4.476188780274242, 6.400627136230469], [334.35483373561874, -5.1499694040976465, 6.549125671386719], [334.1571446725866, -22.56411628704518, 5.603752136230469], [335.7714366611326, -22.59835487836972, 5.607658386230469], [335.8026372892782, -4.905850363895297, 6.5362396240234375]])
# ㄴ
points3 = np.array([[11.016258578456473, -117.31689670868218, -1.1259078979492188], [9.342794719035737, -117.35539097571746, -1.1449127197265625],[17.86216439155396, -140.73362384270877, -1.2936286926269531], [17.99875191511819, -142.0533947981894, -1.314208984375], [52.66503781406209, -141.75403745751828, -1.1653060913085938], [52.157319977879524, -140.1912480192259, -1.1571388244628906], [19.353418086539023, -140.27151586208493, -1.2402153015136719], [11.016258578456473, -117.31689670868218, -1.1259078979492188]])
# ㅁ
points4 = np.array([[299.2354222671711, -147.62040700623766, -0.17055511474609375], [299.10851954540703, -125.5695642568171, 0.1854095458984375], [297.42069565778365, -123.70631024800241, 0.2252044677734375], [297.34262516722083, -147.76535225473344, -0.1437530517578125], [299.286220168462, -149.5427067647688, -0.24664306640625], [334.8655746917939, -148.59316859440878, -0.4355659484863281],[335.38165973022114, -125.60707621835172, -0.26401519775390625],[297.5138763083378, -123.66482217703015, 0.22534942626953125], [299.10948756698053, -125.52392279310152, 0.18540191650390625], [333.7473370357766, -127.17351333098486, -0.18453216552734375], [333.37042167951586, -147.10930879134685, -0.3539390563964844], [299.2354222671711, -147.62040700623766, -0.17055511474609375]])
# 정상(계단식), 그려지면 안됨
points5 = np.array([[301.3108868454583, -119.93538525421172, 0.2494354248046875], [301.1610328737879, -123.88087078835815, 0.16506195068359375], [335.15173311461695, -125.44152805954218, -0.26232147216796875], [335.2248310879804, -123.11775700096041, -0.26157379150390625], [334.3491504043923, -123.090860825032, -0.255096435546875], [334.3476989386836, -122.20371770253405, -0.23845672607421875], [333.40137342282105, -122.16337978327647, -0.224884033203125], [333.4381809398765, -121.38940492365509, -0.211029052734375], [301.3108868454583, -119.93538525421172, 0.2494354248046875]])
# 보행자 횡단보도 평행하게
points6 =  np.array([[449.40061203815276, -336.11447584675625, -2.344524383544922], [444.5998295992613, -337.9416943783872, -2.2262840270996094], [444.95839694410097, -338.86179403588176, -2.2250709533691406], [440.39735830033896, -340.58325046673417, -2.2981529235839844], [443.4781599374837, -351.3962438008748, -2.2784194946289062], [448.9658619791153, -349.24491340946406, -2.2491455078125], [447.3643485981738, -345.0138447987847, -2.169605255126953], [449.3169511736487, -350.00688064144924, -2.257495880126953], [453.3281140853651, -348.4644797653891, -2.249469757080078], [449.40061203815276, -336.11447584675625, -2.344524383544922]])
# 정상, 대각선 심한(/)
points7 =  np.array([[80.2889554243302, -543.9519555303268, 1.9413833618164062], [84.36474134214222, -544.1524252966046, 1.8526840209960938], [90.94894147501327, -521.5814227438532, 1.6098251342773438], [86.78773040871602, -521.379140927922, 1.6959075927734375], [80.2889554243302, -543.9519555303268, 1.9413833618164062]])
# 정상, 대각선 심한(/)
points8 = np.array([[-52.243894472543616, -782.9814879503101, 3.95135498046875], [-50.272497477184515, -782.9991200375371, 3.9657974243164062], [-26.753169911098666, -742.0904500363395, 4.016029357910156], [-27.958245023852214, -741.0788871366531, 4.0046234130859375], [-52.243894472543616, -782.9814879503101, 3.95135498046875]])
# <
points9 = np.array([[-334.8176737004542, 355.3146592117846, 2.834564208984375], [-347.4094554762123, 343.88223137008026, 2.7754058837890625], [-347.7503619554918, 341.5324908616021, 2.6826019287109375], [-340.3243283923948, 330.4443904403597, 2.4340438842773438], [-338.33119159773923, 330.27733636507764, 2.4301681518554688], [-346.52937601332087, 342.6295875287615, 2.7351837158203125], [-333.66810562554747, 354.1153913503513, 2.8255767822265625], [-334.8176737004542, 355.3146592117846, 2.834564208984375]])

points_list.append(points1)
points_list.append(points2)
points_list.append(points3)
points_list.append(points4)
points_list.append(points5)
points_list.append(points6)
points_list.append(points7)
points_list.append(points8)
points_list.append(points9)


def divide_polygon(points):
    
    # min_x = np.nanmin(points[:, 0])
    # max_x = np.nanmax(points[:, 0])
    # min_y = np.nanmin(points[:, 1])
    # max_y = np.nanmax(points[:, 1])

    # pgroup = np.array([
    #     [min_x, min_y],
    #     [max_x, min_y],
    #     [max_x, max_y],
    #     [min_x, max_y]])

    pgroup = minimum_bounding_rectangle(points)
    # 대각선일때는 min이랑 max랑 차이가 많이 나니까 최소길이가 크면 안바꾸는걸로
    # 두개만 비교
    dist1 = np.sqrt(sum(((pgroup[0][0:2]-pgroup[1][0:2])**2)))
    dist2 = np.sqrt(sum(((pgroup[0][0:2]-pgroup[-1][0:2])**2)))
    real = [[], [] , [] , []]
    if (dist1 < 10) or (dist2 < 10):
        return
    vgroup = []
    cpit = calculate_centroid(points)[0:2]
    # heading_vec = (p1-p0) / np.linalg.norm(p1-p0)
    for i, v in enumerate(pgroup):
        conter_vec = (v[0:2]-cpit) / np.linalg.norm(v[0:2]-cpit)
        plist = []
        for point in points:
            heading_vec = (point[0:2]-cpit) / np.linalg.norm(point[0:2]-cpit)
            print(np.inner(conter_vec, heading_vec))
            if np.inner(conter_vec, heading_vec) > 0.8:
                plist.append([point[0], point[1], point[2]])
        real[i] = plist
    
    # com_list = real[0] + real[1] + real[2] + real[3]
    # plist = []
    # for point in points:
    #     if point not in np.array(com_list):
    #         plist.append([point[0], point[1], point[2]])
    # for i in range(4):
    #     if len(real[i]) == 0:
    #         real[i] = plist
    #         break

    return real

def plot_test():


    for i, points in enumerate(points_list):

        x, y, z = points.T
        plt.subplot(3,3,i+1)

        plt.plot(x, y, c='black')
        # plt.scatter(x, y, c='black')

        cpit = calculate_centroid(points)
        plt.scatter(cpit[0], cpit[1], c='black')

        rect = minimum_bounding_rectangle(points)
        for i in rect:
            plt.scatter(i[0], i[1], c='yellow')

        plist = divide_polygon(points)

        if plist is None:
            continue

        for i in plist[0]:
            plt.scatter(i[0], i[1], c='red')
        for i in plist[1]:
            plt.scatter(i[0], i[1], c='orange')
        for i in plist[2]:
            plt.scatter(i[0], i[1], c='green')
        for i in plist[3]:
            plt.scatter(i[0], i[1], c='blue')
        
        nplist = []
        if len(plist[0]) > 0 and len(plist[1]) > 0:
            new_points = minimum_bounding_rectangle(np.vstack((plist[0], plist[1])))
            nplist.append(new_points)

        if len(plist[1]) > 0 and len(plist[2]) > 0:
            new_points = minimum_bounding_rectangle(np.vstack((plist[1], plist[2])))
            nplist.append(new_points)

        if len(plist[2]) > 0 and len(plist[3]) > 0:
            new_points = minimum_bounding_rectangle(np.vstack((plist[2], plist[3])))
            nplist.append(new_points)

        if len(plist[3]) > 0 and len(plist[0]) > 0:
            new_points = minimum_bounding_rectangle(np.vstack((plist[3], plist[0])))
            nplist.append(new_points)

        # 필요없는 네모 뺴기 ㄱ 모양 이상해ㅜㅜㅜ왜이상해...왜...?
        for i, ps in enumerate(nplist):
            min_x = np.nanmin(ps[:, 0])
            max_x = np.nanmax(ps[:, 0])
            min_y = np.nanmin(ps[:, 1])
            max_y = np.nanmax(ps[:, 1])
            if max_x - min_x < 1 or max_y- min_y < 1:
                nplist.pop(i)


        for i in nplist:
            i = np.vstack((i, i[0]))
            x2, y2, z2 = i.T
            plt.plot(x2, y2)


    plt.show()


if __name__ == "__main__":
    plot_test()
